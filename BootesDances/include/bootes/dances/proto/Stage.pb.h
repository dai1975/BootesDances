// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Stage.proto

#ifndef PROTOBUF_Stage_2eproto__INCLUDED
#define PROTOBUF_Stage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "Motion.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Stage_2eproto();
void protobuf_AssignDesc_Stage_2eproto();
void protobuf_ShutdownFile_Stage_2eproto();

class Point;
class Move;
class Move_Line;
class Move_Ellipse;
class Move_Spline;
class Stage;

// ===================================================================

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();
  
  Point(const Point& from);
  
  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();
  
  void Swap(Point* other);
  
  // implements Message ----------------------------------------------
  
  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // @@protoc_insertion_point(class_scope:pb.Point)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Move_Line : public ::google::protobuf::Message {
 public:
  Move_Line();
  virtual ~Move_Line();
  
  Move_Line(const Move_Line& from);
  
  inline Move_Line& operator=(const Move_Line& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Move_Line& default_instance();
  
  void Swap(Move_Line* other);
  
  // implements Message ----------------------------------------------
  
  Move_Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move_Line& from);
  void MergeFrom(const Move_Line& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .pb.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::pb::Point& points(int index) const;
  inline ::pb::Point* mutable_points(int index);
  inline ::pb::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Point >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:pb.Move.Line)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::pb::Point > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Move_Line* default_instance_;
};
// -------------------------------------------------------------------

class Move_Ellipse : public ::google::protobuf::Message {
 public:
  Move_Ellipse();
  virtual ~Move_Ellipse();
  
  Move_Ellipse(const Move_Ellipse& from);
  
  inline Move_Ellipse& operator=(const Move_Ellipse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Move_Ellipse& default_instance();
  
  void Swap(Move_Ellipse* other);
  
  // implements Message ----------------------------------------------
  
  Move_Ellipse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move_Ellipse& from);
  void MergeFrom(const Move_Ellipse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .pb.Point center = 1;
  inline bool has_center() const;
  inline void clear_center();
  static const int kCenterFieldNumber = 1;
  inline const ::pb::Point& center() const;
  inline ::pb::Point* mutable_center();
  inline ::pb::Point* release_center();
  
  // required .pb.Point radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline const ::pb::Point& radius() const;
  inline ::pb::Point* mutable_radius();
  inline ::pb::Point* release_radius();
  
  // required float angle0 = 3;
  inline bool has_angle0() const;
  inline void clear_angle0();
  static const int kAngle0FieldNumber = 3;
  inline float angle0() const;
  inline void set_angle0(float value);
  
  // required float angle1 = 4;
  inline bool has_angle1() const;
  inline void clear_angle1();
  static const int kAngle1FieldNumber = 4;
  inline float angle1() const;
  inline void set_angle1(float value);
  
  // required bool direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline bool direction() const;
  inline void set_direction(bool value);
  
  // @@protoc_insertion_point(class_scope:pb.Move.Ellipse)
 private:
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_angle0();
  inline void clear_has_angle0();
  inline void set_has_angle1();
  inline void clear_has_angle1();
  inline void set_has_direction();
  inline void clear_has_direction();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::pb::Point* center_;
  ::pb::Point* radius_;
  float angle0_;
  float angle1_;
  bool direction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Move_Ellipse* default_instance_;
};
// -------------------------------------------------------------------

class Move_Spline : public ::google::protobuf::Message {
 public:
  Move_Spline();
  virtual ~Move_Spline();
  
  Move_Spline(const Move_Spline& from);
  
  inline Move_Spline& operator=(const Move_Spline& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Move_Spline& default_instance();
  
  void Swap(Move_Spline* other);
  
  // implements Message ----------------------------------------------
  
  Move_Spline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move_Spline& from);
  void MergeFrom(const Move_Spline& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .pb.Point points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::pb::Point& points(int index) const;
  inline ::pb::Point* mutable_points(int index);
  inline ::pb::Point* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Point >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Point >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:pb.Move.Spline)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::pb::Point > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Move_Spline* default_instance_;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::Message {
 public:
  Move();
  virtual ~Move();
  
  Move(const Move& from);
  
  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Move& default_instance();
  
  void Swap(Move* other);
  
  // implements Message ----------------------------------------------
  
  Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Move_Line Line;
  typedef Move_Ellipse Ellipse;
  typedef Move_Spline Spline;
  
  // accessors -------------------------------------------------------
  
  // required string uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const char* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  
  // required int64 time0 = 2;
  inline bool has_time0() const;
  inline void clear_time0();
  static const int kTime0FieldNumber = 2;
  inline ::google::protobuf::int64 time0() const;
  inline void set_time0(::google::protobuf::int64 value);
  
  // required int64 time1 = 3;
  inline bool has_time1() const;
  inline void clear_time1();
  static const int kTime1FieldNumber = 3;
  inline ::google::protobuf::int64 time1() const;
  inline void set_time1(::google::protobuf::int64 value);
  
  // required bool chainnext = 4;
  inline bool has_chainnext() const;
  inline void clear_chainnext();
  static const int kChainnextFieldNumber = 4;
  inline bool chainnext() const;
  inline void set_chainnext(bool value);
  
  // repeated .pb.Motion motions = 10;
  inline int motions_size() const;
  inline void clear_motions();
  static const int kMotionsFieldNumber = 10;
  inline const ::pb::Motion& motions(int index) const;
  inline ::pb::Motion* mutable_motions(int index);
  inline ::pb::Motion* add_motions();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Motion >&
      motions() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Motion >*
      mutable_motions();
  
  // optional .pb.Move.Line line = 100;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 100;
  inline const ::pb::Move_Line& line() const;
  inline ::pb::Move_Line* mutable_line();
  inline ::pb::Move_Line* release_line();
  
  // optional .pb.Move.Ellipse ellipse = 101;
  inline bool has_ellipse() const;
  inline void clear_ellipse();
  static const int kEllipseFieldNumber = 101;
  inline const ::pb::Move_Ellipse& ellipse() const;
  inline ::pb::Move_Ellipse* mutable_ellipse();
  inline ::pb::Move_Ellipse* release_ellipse();
  
  // optional .pb.Move.Spline spline = 102;
  inline bool has_spline() const;
  inline void clear_spline();
  static const int kSplineFieldNumber = 102;
  inline const ::pb::Move_Spline& spline() const;
  inline ::pb::Move_Spline* mutable_spline();
  inline ::pb::Move_Spline* release_spline();
  
  // @@protoc_insertion_point(class_scope:pb.Move)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_time0();
  inline void clear_has_time0();
  inline void set_has_time1();
  inline void clear_has_time1();
  inline void set_has_chainnext();
  inline void clear_has_chainnext();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_ellipse();
  inline void clear_has_ellipse();
  inline void set_has_spline();
  inline void clear_has_spline();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uuid_;
  ::google::protobuf::int64 time0_;
  ::google::protobuf::int64 time1_;
  ::google::protobuf::RepeatedPtrField< ::pb::Motion > motions_;
  ::pb::Move_Line* line_;
  ::pb::Move_Ellipse* ellipse_;
  ::pb::Move_Spline* spline_;
  bool chainnext_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Move* default_instance_;
};
// -------------------------------------------------------------------

class Stage : public ::google::protobuf::Message {
 public:
  Stage();
  virtual ~Stage();
  
  Stage(const Stage& from);
  
  inline Stage& operator=(const Stage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stage& default_instance();
  
  void Swap(Stage* other);
  
  // implements Message ----------------------------------------------
  
  Stage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stage& from);
  void MergeFrom(const Stage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string moviepath = 3;
  inline bool has_moviepath() const;
  inline void clear_moviepath();
  static const int kMoviepathFieldNumber = 3;
  inline const ::std::string& moviepath() const;
  inline void set_moviepath(const ::std::string& value);
  inline void set_moviepath(const char* value);
  inline void set_moviepath(const char* value, size_t size);
  inline ::std::string* mutable_moviepath();
  inline ::std::string* release_moviepath();
  
  // required bool hflip = 4;
  inline bool has_hflip() const;
  inline void clear_hflip();
  static const int kHflipFieldNumber = 4;
  inline bool hflip() const;
  inline void set_hflip(bool value);
  
  // repeated .pb.Move moves = 10;
  inline int moves_size() const;
  inline void clear_moves();
  static const int kMovesFieldNumber = 10;
  inline const ::pb::Move& moves(int index) const;
  inline ::pb::Move* mutable_moves(int index);
  inline ::pb::Move* add_moves();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::Move >&
      moves() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::Move >*
      mutable_moves();
  
  // @@protoc_insertion_point(class_scope:pb.Stage)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_moviepath();
  inline void clear_has_moviepath();
  inline void set_has_hflip();
  inline void clear_has_hflip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 version_;
  bool hflip_;
  ::std::string* moviepath_;
  ::google::protobuf::RepeatedPtrField< ::pb::Move > moves_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Stage_2eproto();
  friend void protobuf_AssignDesc_Stage_2eproto();
  friend void protobuf_ShutdownFile_Stage_2eproto();
  
  void InitAsDefaultInstance();
  static Stage* default_instance_;
};
// ===================================================================


// ===================================================================

// Point

// required float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// Move_Line

// repeated .pb.Point points = 1;
inline int Move_Line::points_size() const {
  return points_.size();
}
inline void Move_Line::clear_points() {
  points_.Clear();
}
inline const ::pb::Point& Move_Line::points(int index) const {
  return points_.Get(index);
}
inline ::pb::Point* Move_Line::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::pb::Point* Move_Line::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Point >&
Move_Line::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Point >*
Move_Line::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// Move_Ellipse

// required .pb.Point center = 1;
inline bool Move_Ellipse::has_center() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move_Ellipse::set_has_center() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move_Ellipse::clear_has_center() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move_Ellipse::clear_center() {
  if (center_ != NULL) center_->::pb::Point::Clear();
  clear_has_center();
}
inline const ::pb::Point& Move_Ellipse::center() const {
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::pb::Point* Move_Ellipse::mutable_center() {
  set_has_center();
  if (center_ == NULL) center_ = new ::pb::Point;
  return center_;
}
inline ::pb::Point* Move_Ellipse::release_center() {
  clear_has_center();
  ::pb::Point* temp = center_;
  center_ = NULL;
  return temp;
}

// required .pb.Point radius = 2;
inline bool Move_Ellipse::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move_Ellipse::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move_Ellipse::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move_Ellipse::clear_radius() {
  if (radius_ != NULL) radius_->::pb::Point::Clear();
  clear_has_radius();
}
inline const ::pb::Point& Move_Ellipse::radius() const {
  return radius_ != NULL ? *radius_ : *default_instance_->radius_;
}
inline ::pb::Point* Move_Ellipse::mutable_radius() {
  set_has_radius();
  if (radius_ == NULL) radius_ = new ::pb::Point;
  return radius_;
}
inline ::pb::Point* Move_Ellipse::release_radius() {
  clear_has_radius();
  ::pb::Point* temp = radius_;
  radius_ = NULL;
  return temp;
}

// required float angle0 = 3;
inline bool Move_Ellipse::has_angle0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Move_Ellipse::set_has_angle0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Move_Ellipse::clear_has_angle0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Move_Ellipse::clear_angle0() {
  angle0_ = 0;
  clear_has_angle0();
}
inline float Move_Ellipse::angle0() const {
  return angle0_;
}
inline void Move_Ellipse::set_angle0(float value) {
  set_has_angle0();
  angle0_ = value;
}

// required float angle1 = 4;
inline bool Move_Ellipse::has_angle1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Move_Ellipse::set_has_angle1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Move_Ellipse::clear_has_angle1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Move_Ellipse::clear_angle1() {
  angle1_ = 0;
  clear_has_angle1();
}
inline float Move_Ellipse::angle1() const {
  return angle1_;
}
inline void Move_Ellipse::set_angle1(float value) {
  set_has_angle1();
  angle1_ = value;
}

// required bool direction = 5;
inline bool Move_Ellipse::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Move_Ellipse::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Move_Ellipse::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Move_Ellipse::clear_direction() {
  direction_ = false;
  clear_has_direction();
}
inline bool Move_Ellipse::direction() const {
  return direction_;
}
inline void Move_Ellipse::set_direction(bool value) {
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// Move_Spline

// repeated .pb.Point points = 1;
inline int Move_Spline::points_size() const {
  return points_.size();
}
inline void Move_Spline::clear_points() {
  points_.Clear();
}
inline const ::pb::Point& Move_Spline::points(int index) const {
  return points_.Get(index);
}
inline ::pb::Point* Move_Spline::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::pb::Point* Move_Spline::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Point >&
Move_Spline::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Point >*
Move_Spline::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// Move

// required string uuid = 1;
inline bool Move::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& Move::uuid() const {
  return *uuid_;
}
inline void Move::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Move::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void Move::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Move::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* Move::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 time0 = 2;
inline bool Move::has_time0() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move::set_has_time0() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move::clear_has_time0() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move::clear_time0() {
  time0_ = GOOGLE_LONGLONG(0);
  clear_has_time0();
}
inline ::google::protobuf::int64 Move::time0() const {
  return time0_;
}
inline void Move::set_time0(::google::protobuf::int64 value) {
  set_has_time0();
  time0_ = value;
}

// required int64 time1 = 3;
inline bool Move::has_time1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Move::set_has_time1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Move::clear_has_time1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Move::clear_time1() {
  time1_ = GOOGLE_LONGLONG(0);
  clear_has_time1();
}
inline ::google::protobuf::int64 Move::time1() const {
  return time1_;
}
inline void Move::set_time1(::google::protobuf::int64 value) {
  set_has_time1();
  time1_ = value;
}

// required bool chainnext = 4;
inline bool Move::has_chainnext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Move::set_has_chainnext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Move::clear_has_chainnext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Move::clear_chainnext() {
  chainnext_ = false;
  clear_has_chainnext();
}
inline bool Move::chainnext() const {
  return chainnext_;
}
inline void Move::set_chainnext(bool value) {
  set_has_chainnext();
  chainnext_ = value;
}

// repeated .pb.Motion motions = 10;
inline int Move::motions_size() const {
  return motions_.size();
}
inline void Move::clear_motions() {
  motions_.Clear();
}
inline const ::pb::Motion& Move::motions(int index) const {
  return motions_.Get(index);
}
inline ::pb::Motion* Move::mutable_motions(int index) {
  return motions_.Mutable(index);
}
inline ::pb::Motion* Move::add_motions() {
  return motions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Motion >&
Move::motions() const {
  return motions_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Motion >*
Move::mutable_motions() {
  return &motions_;
}

// optional .pb.Move.Line line = 100;
inline bool Move::has_line() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Move::set_has_line() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Move::clear_has_line() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Move::clear_line() {
  if (line_ != NULL) line_->::pb::Move_Line::Clear();
  clear_has_line();
}
inline const ::pb::Move_Line& Move::line() const {
  return line_ != NULL ? *line_ : *default_instance_->line_;
}
inline ::pb::Move_Line* Move::mutable_line() {
  set_has_line();
  if (line_ == NULL) line_ = new ::pb::Move_Line;
  return line_;
}
inline ::pb::Move_Line* Move::release_line() {
  clear_has_line();
  ::pb::Move_Line* temp = line_;
  line_ = NULL;
  return temp;
}

// optional .pb.Move.Ellipse ellipse = 101;
inline bool Move::has_ellipse() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Move::set_has_ellipse() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Move::clear_has_ellipse() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Move::clear_ellipse() {
  if (ellipse_ != NULL) ellipse_->::pb::Move_Ellipse::Clear();
  clear_has_ellipse();
}
inline const ::pb::Move_Ellipse& Move::ellipse() const {
  return ellipse_ != NULL ? *ellipse_ : *default_instance_->ellipse_;
}
inline ::pb::Move_Ellipse* Move::mutable_ellipse() {
  set_has_ellipse();
  if (ellipse_ == NULL) ellipse_ = new ::pb::Move_Ellipse;
  return ellipse_;
}
inline ::pb::Move_Ellipse* Move::release_ellipse() {
  clear_has_ellipse();
  ::pb::Move_Ellipse* temp = ellipse_;
  ellipse_ = NULL;
  return temp;
}

// optional .pb.Move.Spline spline = 102;
inline bool Move::has_spline() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Move::set_has_spline() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Move::clear_has_spline() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Move::clear_spline() {
  if (spline_ != NULL) spline_->::pb::Move_Spline::Clear();
  clear_has_spline();
}
inline const ::pb::Move_Spline& Move::spline() const {
  return spline_ != NULL ? *spline_ : *default_instance_->spline_;
}
inline ::pb::Move_Spline* Move::mutable_spline() {
  set_has_spline();
  if (spline_ == NULL) spline_ = new ::pb::Move_Spline;
  return spline_;
}
inline ::pb::Move_Spline* Move::release_spline() {
  clear_has_spline();
  ::pb::Move_Spline* temp = spline_;
  spline_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Stage

// required int32 version = 1;
inline bool Stage::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stage::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stage::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stage::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Stage::version() const {
  return version_;
}
inline void Stage::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required string name = 2;
inline bool Stage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Stage::name() const {
  return *name_;
}
inline void Stage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Stage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Stage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string moviepath = 3;
inline bool Stage::has_moviepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stage::set_has_moviepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stage::clear_has_moviepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stage::clear_moviepath() {
  if (moviepath_ != &::google::protobuf::internal::kEmptyString) {
    moviepath_->clear();
  }
  clear_has_moviepath();
}
inline const ::std::string& Stage::moviepath() const {
  return *moviepath_;
}
inline void Stage::set_moviepath(const ::std::string& value) {
  set_has_moviepath();
  if (moviepath_ == &::google::protobuf::internal::kEmptyString) {
    moviepath_ = new ::std::string;
  }
  moviepath_->assign(value);
}
inline void Stage::set_moviepath(const char* value) {
  set_has_moviepath();
  if (moviepath_ == &::google::protobuf::internal::kEmptyString) {
    moviepath_ = new ::std::string;
  }
  moviepath_->assign(value);
}
inline void Stage::set_moviepath(const char* value, size_t size) {
  set_has_moviepath();
  if (moviepath_ == &::google::protobuf::internal::kEmptyString) {
    moviepath_ = new ::std::string;
  }
  moviepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stage::mutable_moviepath() {
  set_has_moviepath();
  if (moviepath_ == &::google::protobuf::internal::kEmptyString) {
    moviepath_ = new ::std::string;
  }
  return moviepath_;
}
inline ::std::string* Stage::release_moviepath() {
  clear_has_moviepath();
  if (moviepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = moviepath_;
    moviepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool hflip = 4;
inline bool Stage::has_hflip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Stage::set_has_hflip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Stage::clear_has_hflip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Stage::clear_hflip() {
  hflip_ = false;
  clear_has_hflip();
}
inline bool Stage::hflip() const {
  return hflip_;
}
inline void Stage::set_hflip(bool value) {
  set_has_hflip();
  hflip_ = value;
}

// repeated .pb.Move moves = 10;
inline int Stage::moves_size() const {
  return moves_.size();
}
inline void Stage::clear_moves() {
  moves_.Clear();
}
inline const ::pb::Move& Stage::moves(int index) const {
  return moves_.Get(index);
}
inline ::pb::Move* Stage::mutable_moves(int index) {
  return moves_.Mutable(index);
}
inline ::pb::Move* Stage::add_moves() {
  return moves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Move >&
Stage::moves() const {
  return moves_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Move >*
Stage::mutable_moves() {
  return &moves_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Stage_2eproto__INCLUDED
