// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "bootes/dances/proto/Teach.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace pb {

namespace {

const ::google::protobuf::Descriptor* TeachRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TeachRecord_reflection_ = NULL;
const ::google::protobuf::Descriptor* TeachSequence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TeachSequence_reflection_ = NULL;
const ::google::protobuf::Descriptor* TeachClear_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TeachClear_reflection_ = NULL;
const ::google::protobuf::Descriptor* TeachCommand_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TeachCommand_reflection_ = NULL;
const ::google::protobuf::Descriptor* TeachLog_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TeachLog_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_bootes_2fdances_2fproto_2fTeach_2eproto() {
  protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "bootes/dances/proto/Teach.proto");
  GOOGLE_CHECK(file != NULL);
  TeachRecord_descriptor_ = file->message_type(0);
  static const int TeachRecord_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachRecord, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachRecord, accel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachRecord, gyro_),
  };
  TeachRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TeachRecord_descriptor_,
      TeachRecord::default_instance_,
      TeachRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TeachRecord));
  TeachSequence_descriptor_ = file->message_type(1);
  static const int TeachSequence_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachSequence, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachSequence, succeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachSequence, records_),
  };
  TeachSequence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TeachSequence_descriptor_,
      TeachSequence::default_instance_,
      TeachSequence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachSequence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachSequence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TeachSequence));
  TeachClear_descriptor_ = file->message_type(2);
  static const int TeachClear_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachClear, uuid_),
  };
  TeachClear_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TeachClear_descriptor_,
      TeachClear::default_instance_,
      TeachClear_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachClear, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachClear, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TeachClear));
  TeachCommand_descriptor_ = file->message_type(3);
  static const int TeachCommand_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachCommand, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachCommand, clear_),
  };
  TeachCommand_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TeachCommand_descriptor_,
      TeachCommand::default_instance_,
      TeachCommand_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachCommand, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachCommand, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TeachCommand));
  TeachLog_descriptor_ = file->message_type(4);
  static const int TeachLog_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachLog, commands_),
  };
  TeachLog_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TeachLog_descriptor_,
      TeachLog::default_instance_,
      TeachLog_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachLog, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TeachLog, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TeachLog));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_bootes_2fdances_2fproto_2fTeach_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TeachRecord_descriptor_, &TeachRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TeachSequence_descriptor_, &TeachSequence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TeachClear_descriptor_, &TeachClear::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TeachCommand_descriptor_, &TeachCommand::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TeachLog_descriptor_, &TeachLog::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_bootes_2fdances_2fproto_2fTeach_2eproto() {
  delete TeachRecord::default_instance_;
  delete TeachRecord_reflection_;
  delete TeachSequence::default_instance_;
  delete TeachSequence_reflection_;
  delete TeachClear::default_instance_;
  delete TeachClear_reflection_;
  delete TeachCommand::default_instance_;
  delete TeachCommand_reflection_;
  delete TeachLog::default_instance_;
  delete TeachLog_reflection_;
}

void protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::pb::protobuf_AddDesc_bootes_2fdances_2fproto_2fStage_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\037bootes/dances/proto/Teach.proto\022\002pb\032\037b"
    "ootes/dances/proto/Stage.proto\"M\n\013TeachR"
    "ecord\022\014\n\004time\030\001 \002(\005\022\030\n\005accel\030\n \002(\0132\t.pb."
    "Accel\022\026\n\004gyro\030\013 \002(\0132\010.pb.Gyro\"P\n\rTeachSe"
    "quence\022\014\n\004uuid\030\001 \002(\t\022\017\n\007succeed\030\002 \002(\010\022 \n"
    "\007records\030\003 \003(\0132\017.pb.TeachRecord\"\032\n\nTeach"
    "Clear\022\014\n\004uuid\030\001 \002(\t\"R\n\014TeachCommand\022#\n\010s"
    "equence\030\001 \001(\0132\021.pb.TeachSequence\022\035\n\005clea"
    "r\030\002 \001(\0132\016.pb.TeachClear\".\n\010TeachLog\022\"\n\010c"
    "ommands\030\001 \003(\0132\020.pb.TeachCommand", 391);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "bootes/dances/proto/Teach.proto", &protobuf_RegisterTypes);
  TeachRecord::default_instance_ = new TeachRecord();
  TeachSequence::default_instance_ = new TeachSequence();
  TeachClear::default_instance_ = new TeachClear();
  TeachCommand::default_instance_ = new TeachCommand();
  TeachLog::default_instance_ = new TeachLog();
  TeachRecord::default_instance_->InitAsDefaultInstance();
  TeachSequence::default_instance_->InitAsDefaultInstance();
  TeachClear::default_instance_->InitAsDefaultInstance();
  TeachCommand::default_instance_->InitAsDefaultInstance();
  TeachLog::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_bootes_2fdances_2fproto_2fTeach_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_bootes_2fdances_2fproto_2fTeach_2eproto {
  StaticDescriptorInitializer_bootes_2fdances_2fproto_2fTeach_2eproto() {
    protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();
  }
} static_descriptor_initializer_bootes_2fdances_2fproto_2fTeach_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int TeachRecord::kTimeFieldNumber;
const int TeachRecord::kAccelFieldNumber;
const int TeachRecord::kGyroFieldNumber;
#endif  // !_MSC_VER

TeachRecord::TeachRecord()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TeachRecord::InitAsDefaultInstance() {
  accel_ = const_cast< ::pb::Accel*>(&::pb::Accel::default_instance());
  gyro_ = const_cast< ::pb::Gyro*>(&::pb::Gyro::default_instance());
}

TeachRecord::TeachRecord(const TeachRecord& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TeachRecord::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  accel_ = NULL;
  gyro_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeachRecord::~TeachRecord() {
  SharedDtor();
}

void TeachRecord::SharedDtor() {
  if (this != default_instance_) {
    delete accel_;
    delete gyro_;
  }
}

void TeachRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TeachRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeachRecord_descriptor_;
}

const TeachRecord& TeachRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();  return *default_instance_;
}

TeachRecord* TeachRecord::default_instance_ = NULL;

TeachRecord* TeachRecord::New() const {
  return new TeachRecord;
}

void TeachRecord::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_accel()) {
      if (accel_ != NULL) accel_->::pb::Accel::Clear();
    }
    if (has_gyro()) {
      if (gyro_ != NULL) gyro_->::pb::Gyro::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TeachRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_accel;
        break;
      }
      
      // required .pb.Accel accel = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_accel:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_accel()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_gyro;
        break;
      }
      
      // required .pb.Gyro gyro = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_gyro:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gyro()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TeachRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->time(), output);
  }
  
  // required .pb.Accel accel = 10;
  if (has_accel()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->accel(), output);
  }
  
  // required .pb.Gyro gyro = 11;
  if (has_gyro()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->gyro(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TeachRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->time(), target);
  }
  
  // required .pb.Accel accel = 10;
  if (has_accel()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->accel(), target);
  }
  
  // required .pb.Gyro gyro = 11;
  if (has_gyro()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->gyro(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TeachRecord::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time());
    }
    
    // required .pb.Accel accel = 10;
    if (has_accel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->accel());
    }
    
    // required .pb.Gyro gyro = 11;
    if (has_gyro()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gyro());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeachRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TeachRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TeachRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TeachRecord::MergeFrom(const TeachRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_accel()) {
      mutable_accel()->::pb::Accel::MergeFrom(from.accel());
    }
    if (from.has_gyro()) {
      mutable_gyro()->::pb::Gyro::MergeFrom(from.gyro());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TeachRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TeachRecord::CopyFrom(const TeachRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeachRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_accel()) {
    if (!this->accel().IsInitialized()) return false;
  }
  if (has_gyro()) {
    if (!this->gyro().IsInitialized()) return false;
  }
  return true;
}

void TeachRecord::Swap(TeachRecord* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(accel_, other->accel_);
    std::swap(gyro_, other->gyro_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TeachRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TeachRecord_descriptor_;
  metadata.reflection = TeachRecord_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TeachSequence::kUuidFieldNumber;
const int TeachSequence::kSucceedFieldNumber;
const int TeachSequence::kRecordsFieldNumber;
#endif  // !_MSC_VER

TeachSequence::TeachSequence()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TeachSequence::InitAsDefaultInstance() {
}

TeachSequence::TeachSequence(const TeachSequence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TeachSequence::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  succeed_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeachSequence::~TeachSequence() {
  SharedDtor();
}

void TeachSequence::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void TeachSequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TeachSequence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeachSequence_descriptor_;
}

const TeachSequence& TeachSequence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();  return *default_instance_;
}

TeachSequence* TeachSequence::default_instance_ = NULL;

TeachSequence* TeachSequence::New() const {
  return new TeachSequence;
}

void TeachSequence::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
    succeed_ = false;
  }
  records_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TeachSequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_succeed;
        break;
      }
      
      // required bool succeed = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_succeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &succeed_)));
          set_has_succeed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_records;
        break;
      }
      
      // repeated .pb.TeachRecord records = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_records:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_records()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_records;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TeachSequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }
  
  // required bool succeed = 2;
  if (has_succeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->succeed(), output);
  }
  
  // repeated .pb.TeachRecord records = 3;
  for (int i = 0; i < this->records_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->records(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TeachSequence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }
  
  // required bool succeed = 2;
  if (has_succeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->succeed(), target);
  }
  
  // repeated .pb.TeachRecord records = 3;
  for (int i = 0; i < this->records_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->records(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TeachSequence::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }
    
    // required bool succeed = 2;
    if (has_succeed()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .pb.TeachRecord records = 3;
  total_size += 1 * this->records_size();
  for (int i = 0; i < this->records_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->records(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeachSequence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TeachSequence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TeachSequence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TeachSequence::MergeFrom(const TeachSequence& from) {
  GOOGLE_CHECK_NE(&from, this);
  records_.MergeFrom(from.records_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_succeed()) {
      set_succeed(from.succeed());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TeachSequence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TeachSequence::CopyFrom(const TeachSequence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeachSequence::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < records_size(); i++) {
    if (!this->records(i).IsInitialized()) return false;
  }
  return true;
}

void TeachSequence::Swap(TeachSequence* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(succeed_, other->succeed_);
    records_.Swap(&other->records_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TeachSequence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TeachSequence_descriptor_;
  metadata.reflection = TeachSequence_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TeachClear::kUuidFieldNumber;
#endif  // !_MSC_VER

TeachClear::TeachClear()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TeachClear::InitAsDefaultInstance() {
}

TeachClear::TeachClear(const TeachClear& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TeachClear::SharedCtor() {
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeachClear::~TeachClear() {
  SharedDtor();
}

void TeachClear::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (this != default_instance_) {
  }
}

void TeachClear::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TeachClear::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeachClear_descriptor_;
}

const TeachClear& TeachClear::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();  return *default_instance_;
}

TeachClear* TeachClear::default_instance_ = NULL;

TeachClear* TeachClear::New() const {
  return new TeachClear;
}

void TeachClear::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::kEmptyString) {
        uuid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TeachClear::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string uuid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uuid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->uuid().data(), this->uuid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TeachClear::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->uuid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TeachClear::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->uuid().data(), this->uuid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->uuid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TeachClear::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uuid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeachClear::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TeachClear* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TeachClear*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TeachClear::MergeFrom(const TeachClear& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TeachClear::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TeachClear::CopyFrom(const TeachClear& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeachClear::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void TeachClear::Swap(TeachClear* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TeachClear::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TeachClear_descriptor_;
  metadata.reflection = TeachClear_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TeachCommand::kSequenceFieldNumber;
const int TeachCommand::kClearFieldNumber;
#endif  // !_MSC_VER

TeachCommand::TeachCommand()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TeachCommand::InitAsDefaultInstance() {
  sequence_ = const_cast< ::pb::TeachSequence*>(&::pb::TeachSequence::default_instance());
  clear_ = const_cast< ::pb::TeachClear*>(&::pb::TeachClear::default_instance());
}

TeachCommand::TeachCommand(const TeachCommand& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TeachCommand::SharedCtor() {
  _cached_size_ = 0;
  sequence_ = NULL;
  clear_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeachCommand::~TeachCommand() {
  SharedDtor();
}

void TeachCommand::SharedDtor() {
  if (this != default_instance_) {
    delete sequence_;
    delete clear_;
  }
}

void TeachCommand::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TeachCommand::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeachCommand_descriptor_;
}

const TeachCommand& TeachCommand::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();  return *default_instance_;
}

TeachCommand* TeachCommand::default_instance_ = NULL;

TeachCommand* TeachCommand::New() const {
  return new TeachCommand;
}

void TeachCommand::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_sequence()) {
      if (sequence_ != NULL) sequence_->::pb::TeachSequence::Clear();
    }
    if (has_clear()) {
      if (clear_ != NULL) clear_->::pb::TeachClear::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TeachCommand::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .pb.TeachSequence sequence = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sequence()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_clear;
        break;
      }
      
      // optional .pb.TeachClear clear = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clear:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clear()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TeachCommand::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .pb.TeachSequence sequence = 1;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sequence(), output);
  }
  
  // optional .pb.TeachClear clear = 2;
  if (has_clear()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->clear(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TeachCommand::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .pb.TeachSequence sequence = 1;
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sequence(), target);
  }
  
  // optional .pb.TeachClear clear = 2;
  if (has_clear()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->clear(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TeachCommand::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .pb.TeachSequence sequence = 1;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sequence());
    }
    
    // optional .pb.TeachClear clear = 2;
    if (has_clear()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->clear());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeachCommand::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TeachCommand* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TeachCommand*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TeachCommand::MergeFrom(const TeachCommand& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sequence()) {
      mutable_sequence()->::pb::TeachSequence::MergeFrom(from.sequence());
    }
    if (from.has_clear()) {
      mutable_clear()->::pb::TeachClear::MergeFrom(from.clear());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TeachCommand::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TeachCommand::CopyFrom(const TeachCommand& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeachCommand::IsInitialized() const {
  
  if (has_sequence()) {
    if (!this->sequence().IsInitialized()) return false;
  }
  if (has_clear()) {
    if (!this->clear().IsInitialized()) return false;
  }
  return true;
}

void TeachCommand::Swap(TeachCommand* other) {
  if (other != this) {
    std::swap(sequence_, other->sequence_);
    std::swap(clear_, other->clear_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TeachCommand::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TeachCommand_descriptor_;
  metadata.reflection = TeachCommand_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TeachLog::kCommandsFieldNumber;
#endif  // !_MSC_VER

TeachLog::TeachLog()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TeachLog::InitAsDefaultInstance() {
}

TeachLog::TeachLog(const TeachLog& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TeachLog::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TeachLog::~TeachLog() {
  SharedDtor();
}

void TeachLog::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TeachLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TeachLog::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TeachLog_descriptor_;
}

const TeachLog& TeachLog::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_bootes_2fdances_2fproto_2fTeach_2eproto();  return *default_instance_;
}

TeachLog* TeachLog::default_instance_ = NULL;

TeachLog* TeachLog::New() const {
  return new TeachLog;
}

void TeachLog::Clear() {
  commands_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TeachLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .pb.TeachCommand commands = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_commands:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_commands()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_commands;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TeachLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .pb.TeachCommand commands = 1;
  for (int i = 0; i < this->commands_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->commands(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TeachLog::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .pb.TeachCommand commands = 1;
  for (int i = 0; i < this->commands_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->commands(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TeachLog::ByteSize() const {
  int total_size = 0;
  
  // repeated .pb.TeachCommand commands = 1;
  total_size += 1 * this->commands_size();
  for (int i = 0; i < this->commands_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->commands(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TeachLog::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TeachLog* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TeachLog*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TeachLog::MergeFrom(const TeachLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  commands_.MergeFrom(from.commands_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TeachLog::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TeachLog::CopyFrom(const TeachLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TeachLog::IsInitialized() const {
  
  for (int i = 0; i < commands_size(); i++) {
    if (!this->commands(i).IsInitialized()) return false;
  }
  return true;
}

void TeachLog::Swap(TeachLog* other) {
  if (other != this) {
    commands_.Swap(&other->commands_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TeachLog::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TeachLog_descriptor_;
  metadata.reflection = TeachLog_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)
